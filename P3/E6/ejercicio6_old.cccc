#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <ctype.h>

#define MASTER 0
#define UNO 1
#define DOS 2
#define TRES 3

void receive_array(int from, int tag, int **buf_len, double **buf)
{
    MPI_Status status;
    MPI_Probe(from, tag, MPI_COMM_WORLD, &status);
    MPI_Get_count(&status, MPI_DOUBLE, &**buf_len);
    *buf = (double *)realloc(*buf, **buf_len * sizeof(double));
    MPI_Recv(&**buf, **buf_len, MPI_DOUBLE, from, tag, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
}

double myrand()
{
    time_t t;
    srand((unsigned)time(&t));
    double seed = 11111.0 * rand();
    double a = 16807.0,
           m = 2147483647.0;
    double q;
    seed = a * seed;
    q = floor(seed / m);
    seed = seed - q * m;
    double res = (seed / m);
    return res;
}

double *crearVectorAleatorio(int tam)
{
    double *vec = malloc(sizeof(double) * tam);
    for (int i = 0; i < tam; i++)
    {
        vec[i] = myrand();
    }
    return vec;
}

/**
 * Hacer el reparto de forma equitativa.
 * Primero se reparte la parte entera y posteriormete
 * se reparte el resto empezando por el final
 */
int *calculate_intervals(int longitud, int t_number)
{
    int size = t_number * 2;
    int *intervals = (int *)calloc(sizeof(int), size);
    int pack = longitud / t_number;
    int offset = longitud % t_number;

    for (int n = 0; n < 2; n++)
    {
        if (n == 0)
        { //iteracion 0 reparte la parte entera de la division (pack)
            for (int i = 0; i < t_number; i++)
            { //nHilos
                intervals[i * 2] = i * pack;
                intervals[(i * 2) + 1] = i * pack + pack;
            }
        }
        else
        {
            for (int i = size - 1; i > 0; i -= 2)
            { //reparte el offset
                if (offset > 0)
                {
                    intervals[i] += offset;     //desplazar al final el ultimo intervalo
                    offset -= 1;                //disminuir offset.
                    intervals[i - 1] += offset; //siguiente offset es mas peque√±o
                }
            }
        }
    }

    printf("\nintervals: -----------------\n");
    for (int i = 0; i < size; i++)
    {
        printf("%d\t", intervals[i]);
    }
    printf("\n--------------------------\n");
    return intervals;
}

/**
 * vec1 - ingresos
 * vec2 - gastos
 * return: ingresos - gastos
 */
double seqCheck(const double *vec1, const double *vec2, int tam)
{
    //ingresos - gastos
    double res1 = 0.0;
    double res2 = 0.0;
    for (int i = 0; i < tam; i++)
    {
        res1 += vec1[i];
        res2 += vec2[i];
    }
    double res = res1 - res2;
    return res;
}

int main(int argc, char **argv)
{
    MPI_Init(&argc, &argv);
    int world_size, rank;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &world_size);
    
    if (world_size != 4)
    {
        printf("Llamada: mpirun -n n prog\n");
        MPI_Finalize();
        return 0;
    }

    const int char_length = 20;
    char term;
    int number;
    char input_string[20];
    double *vec;
    int condition = 1;
    while (condition == 1)
    {
        if (rank == MASTER)
        {
            puts("Tell me something nice: [0, 1, 2, 3, 4]");
            if (scanf("%d", &number) != 1)
            {
                term = getchar();
                printf("INVALID INPUT: %C\nAVAILABLE OPTIONS: [0,1,2,3,4]\n", term);
            }
            else
            {
                switch (number)
                {
                case 0:
                    condition = 0;
                    MPI_Finalize();
                    return 0;
                case 1:
                    printf("\nEnter string without spaces of length < %d\n", char_length);
                    fflush(stdin);
                    scanf("%s", input_string);
                    MPI_Send(input_string, char_length, MPI_CHAR, UNO, UNO, MPI_COMM_WORLD);
                    MPI_Recv(input_string, char_length, MPI_CHAR, UNO, UNO, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
                    printf("toupper(): %s\n", input_string);
                    fflush(stdout);
                    break;
                case 2:
                    vec = crearVectorAleatorio(10);
                    for (int i = 0; i < 10; i++)
                    {
                        printf("%.2f ", vec[i]);
                    }
                    printf("\n");
                    MPI_Send(vec, 10, MPI_DOUBLE, DOS, DOS, MPI_COMM_WORLD);
                    MPI_Recv(vec, 10, MPI_DOUBLE, DOS, DOS, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
                    for (int i = 0; i < 10; i++)
                    {
                        printf("%.2f ", vec[i]);
                    }
                    printf("\n");
                    fflush(stdout);
                    break;
                case 3:
                    break;
                case 4:
                    break;
                default:
                    printf("INVALID OPTION: %d\nAVAILABLE OPTIONS: [0,1,2,3,4]\n", number);
                    break;
                }
            }
        }
        else if (rank == UNO)
        {
            char buf[char_length];

            MPI_Recv(buf, char_length, MPI_CHAR, MASTER, rank, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            for (int i = 0; i < char_length; i++)
            {
                buf[i] = toupper(buf[i]);
            }
            MPI_Send(buf, char_length, MPI_CHAR, MASTER, rank, MPI_COMM_WORLD);
        }
        else if (rank == DOS)
        {
            double vec[10];

            MPI_Recv(vec, 10, MPI_DOUBLE, MASTER, rank, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            for (int i = 0; i < 10; i++)
            {
                vec[i] *= vec[i];
            }
            MPI_Send(vec, 10, MPI_DOUBLE, MASTER, rank, MPI_COMM_WORLD);
        }
        else if (rank == TRES)
        {
            /* code */
        }
    }
}